<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Sentence Categorizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

h1 {
    color: #667eea;
    margin-bottom: 30px;
    text-align: center;
    font-size: 2.5em;
}

.config-section {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
}

.input-group {
    margin-bottom: 15px;
}

label {
    display: block;
    font-weight: 600;
    margin-bottom: 5px;
    color: #333;
}

input[type="text"], input[type="file"], input[type="number"] {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 16px;
    transition: border 0.3s;
}

input:focus {
    outline: none;
    border-color: #667eea;
}

.btn {
    background: #667eea;
    color: white;
    padding: 15px 30px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    width: 100%;
    margin-top: 10px;
}

.btn:hover:not(:disabled) {
    background: #5568d3;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
}

.btn:disabled {
    background: #ccc;
    cursor: not-allowed;
}

.progress-section {
    margin-top: 30px;
    display: none;
}

.progress-bar {
    width: 100%;
    height: 30px;
    background: #e9ecef;
    border-radius: 15px;
    overflow: hidden;
    margin-bottom: 20px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    width: 0%;
    transition: width 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
}

.status {
    background: #e7f3ff;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid #667eea;
    margin-bottom: 15px;
}

.results-section {
    margin-top: 30px;
    display: none;
}

.category {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    border-left: 4px solid #667eea;
}

.category h3 {
    color: #667eea;
    margin-bottom: 15px;
}

.sentence {
    background: white;
    padding: 10px;
    margin-bottom: 8px;
    border-radius: 5px;
    border-left: 3px solid #ddd;
}

.download-btn {
    background: #28a745;
    margin-top: 20px;
}

.download-btn:hover:not(:disabled) {
    background: #218838;
}

.error {
    background: #f8d7da;
    border-left: 4px solid #dc3545;
    color: #721c24;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
}

.stats {
    background: #e7f3ff;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
}

.stat-item {
    display: inline-block;
    margin-right: 20px;
    font-weight: 600;
}

.stat-value {
    color: #667eea;
}
    </style>
</head>
<body>
    <div class="container">
        <h1>📄 PDF Sentence Categorizer</h1>
        
        <div class="config-section">
            <div class="input-group">
                <label>LongCat API Key:</label>
                <input type="text" id="apiKey" placeholder="Enter your LongCat API key (e.g., ak_...)" value="ak_1Pf2Tk6np3xI3pB8lW4m96OW9Dl4m">
            </div>
            
            <div class="input-group">
                <label>Batch Size (sentences per request):</label>
                <input type="number" id="batchSize" value="50" min="10" max="100">
            </div>
            
            <div class="input-group">
                <label>Select PDF File:</label>
                <input type="file" id="pdfFile" accept=".pdf">
            </div>
            
            <button class="btn" id="startBtn" onclick="startProcessing()">Start Processing</button>
        </div>

        <div class="progress-section" id="progressSection">
            <div class="stats">
                <div class="stat-item">Total Sentences: <span class="stat-value" id="totalSentences">0</span></div>
                <div class="stat-item">Categories: <span class="stat-value" id="totalCategories">0</span></div>
                <div class="stat-item">Processed: <span class="stat-value" id="processedCount">0</span></div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <div class="status" id="statusText">Initializing...</div>
        </div>

        <div class="results-section" id="resultsSection">
            <h2>Categorized Results</h2>
            <div id="categoriesContainer"></div>
            <button class="btn download-btn" onclick="downloadResults()">Download as JSON</button>
            <button class="btn download-btn" onclick="downloadAsPDF()">Download as PDF</button>
        </div>
    </div>

    <script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

let allSentences = [];
let categorizedSentences = {};
let categories = [];

async function extractTextFromPDF(file) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    let fullText = '';
    
    for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(item => item.str).join(' ');
        fullText += pageText + ' ';
    }
    
    return fullText;
}

function splitIntoSentences(text) {
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
    return sentences.map(s => s.trim()).filter(s => s.length > 10);
}

async function callLongCatAPI(apiKey, messages, maxTokens = 2000) {
    const response = await fetch('https://api.longcat.chat/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            model: 'LongCat-Flash-Chat',
            messages: messages,
            max_tokens: maxTokens,
            temperature: 0.3
        })
    });

    if (!response.ok) {
        const error = await response.text();
        throw new Error(`API Error: ${response.status} - ${error}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
}

function updateProgress(percent, status) {
    document.getElementById('progressFill').style.width = percent + '%';
    document.getElementById('progressFill').textContent = Math.round(percent) + '%';
    document.getElementById('statusText').textContent = status;
}

function showError(message) {
    const statusDiv = document.getElementById('statusText');
    statusDiv.className = 'status error';
    statusDiv.textContent = '❌ Error: ' + message;
}

async function identifyCategories(apiKey, sampleSentences) {
    updateProgress(5, 'Step 1/3: Identifying categories from document...');
    
    const prompt = `Analyze these sample sentences from a document and identify 5-10 main categories that cover all topics. Return ONLY a JSON array of category names, nothing else.

Sample sentences:
${sampleSentences.slice(0, 100).join('\n')}

Return format: ["Category1", "Category2", "Category3", ...]`;

    const messages = [
        {role: 'user', content: prompt}
    ];

    const response = await callLongCatAPI(apiKey, messages);
    const jsonMatch = response.match(/\[.*\]/s);
    if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
    }
    throw new Error('Failed to parse categories from AI response');
}

async function categorizeBatch(apiKey, sentences, categories, batchIndex, totalBatches) {
    const percent = 10 + (batchIndex / totalBatches) * 80;
    updateProgress(percent, `Step 2/3: Categorizing batch ${batchIndex + 1}/${totalBatches}...`);

    const prompt = `Categorize each sentence into ONE of these categories: ${categories.join(', ')}.

Sentences:
${sentences.map((s, i) => `${i + 1}. ${s}`).join('\n')}

Return ONLY a JSON array where each element is the category name for the corresponding sentence number. Format: ["Category", "Category", ...]`;

    const messages = [
        {role: 'user', content: prompt}
    ];

    const response = await callLongCatAPI(apiKey, messages);
    const jsonMatch = response.match(/\[.*\]/s);
    if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
    }
    throw new Error('Failed to parse categorization from AI response');
}

function displayResults() {
    updateProgress(100, 'Complete! Displaying results...');
    
    const container = document.getElementById('categoriesContainer');
    container.innerHTML = '';

    for (const [category, sentences] of Object.entries(categorizedSentences)) {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'category';
        
        const title = document.createElement('h3');
        title.textContent = `${category} (${sentences.length} sentences)`;
        categoryDiv.appendChild(title);

        sentences.forEach(sentence => {
            const sentenceDiv = document.createElement('div');
            sentenceDiv.className = 'sentence';
            sentenceDiv.textContent = sentence;
            categoryDiv.appendChild(sentenceDiv);
        });

        container.appendChild(categoryDiv);
    }

    document.getElementById('resultsSection').style.display = 'block';
}

function downloadResults() {
    const dataStr = JSON.stringify(categorizedSentences, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'categorized_sentences.json';
    link.click();
    URL.revokeObjectURL(url);
}

function downloadAsPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    let yPosition = 20;
    
    doc.setFontSize(20);
    doc.text('Categorized Sentences', 20, yPosition);
    yPosition += 20;
    
    for (const [category, sentences] of Object.entries(categorizedSentences)) {
        doc.setFontSize(16);
        doc.setTextColor(0, 0, 0);
        doc.text(`${category} (${sentences.length} sentences)`, 20, yPosition);
        yPosition += 10;
        
        doc.setFontSize(12);
        doc.setTextColor(100, 100, 100);
        
        for (const sentence of sentences) {
            if (yPosition > 280) {
                doc.addPage();
                yPosition = 20;
            }
            
            const wrappedText = doc.splitTextToSize(sentence, 170);
            doc.text(wrappedText, 20, yPosition);
            yPosition += (wrappedText.length * 8) + 5;
        }
        
        yPosition += 10;
    }
    
    doc.save('categorized_sentences.pdf');
}

async function startProcessing() {
    const apiKey = document.getElementById('apiKey').value.trim();
    const batchSize = parseInt(document.getElementById('batchSize').value);
    const fileInput = document.getElementById('pdfFile');

    if (!apiKey) {
        alert('Please enter your LongCat API key');
        return;
    }

    if (!fileInput.files[0]) {
        alert('Please select a PDF file');
        return;
    }

    document.getElementById('startBtn').disabled = true;
    document.getElementById('progressSection').style.display = 'block';
    document.getElementById('resultsSection').style.display = 'none';

    try {
        // Step 1: Extract text from PDF
        updateProgress(0, 'Extracting text from PDF...');
        const text = await extractTextFromPDF(fileInput.files[0]);
        allSentences = splitIntoSentences(text);
        
        document.getElementById('totalSentences').textContent = allSentences.length;
        
        if (allSentences.length === 0) {
            throw new Error('No sentences found in PDF');
        }

        updateProgress(3, `Found ${allSentences.length} sentences. Analyzing...`);

        // Step 2: Identify categories
        categories = await identifyCategories(apiKey, allSentences);
        document.getElementById('totalCategories').textContent = categories.length;
        updateProgress(10, `Identified ${categories.length} categories: ${categories.join(', ')}`);

        // Initialize category storage
        categorizedSentences = {};
        categories.forEach(cat => categorizedSentences[cat] = []);

        // Step 3: Process in batches
        const totalBatches = Math.ceil(allSentences.length / batchSize);
        
        for (let i = 0; i < totalBatches; i++) {
            const start = i * batchSize;
            const end = Math.min(start + batchSize, allSentences.length);
            const batch = allSentences.slice(start, end);

            const batchCategories = await categorizeBatch(apiKey, batch, categories, i, totalBatches);

            // Store categorized sentences
            batch.forEach((sentence, idx) => {
                const category = batchCategories[idx] || 'Uncategorized';
                if (!categorizedSentences[category]) {
                    categorizedSentences[category] = [];
                }
                categorizedSentences[category].push(sentence);
            });

            document.getElementById('processedCount').textContent = end;

            // Small delay to avoid rate limits
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        // Display results
        displayResults();

    } catch (error) {
        showError(error.message);
        console.error('Processing error:', error);
    } finally {
        document.getElementById('startBtn').disabled = false;
    }
}
    </script>
</body>
</html>